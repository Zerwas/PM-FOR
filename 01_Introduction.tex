\begin{abstract}
A \lambdaTwo{} type is inhabited in \lambdaTwo{} iff there is a closed \lambdaTwo{} term of this type. The inhabitation problem in \lambdaTwo{} is to determine whether a given \lambdaTwo{} type is inhabited. This work gives a formal proof for the fact that the inhabitation problem in \lambdaTwo{} is undecidable.
\end{abstract}

\section{Introduction}\label{sec.1}
We will only consider the explicitly typed \lambdaTwo{} calculus (Church style), so whenever we speak of \lambdaTwo{} terms we know that the type information is given explicitly. 
Let us take a look at the problem. It is clear that there are closed \lambdaTwo{} terms to which no \lambdaTwo{} type can be assigned (e.g. to the \lambdaTwo{} term $(\lambda x:\forall\alpha\alpha.xx)(\lambda x:\forall\alpha\alpha.xx)$ no type can be assigned). But there are also \lambdaTwo{} types which can not be assigned to any closed \lambdaTwo{} term. We say that these types are empty. For instance the \lambdaTwo{} type $\forall\alpha\alpha$ is empty.

%For a programmer it is good to know whether a function of a given type even exists
In what follows we will prove that the inhabitation problem in \lambdaTwo{} is undecidable. We do this by reducing the halting problem for two-counter automaton to the consistency problem of System \SysP{} (a restricted version of first-order logic). Finally we reduce the consistency problem to the inhabitation problem in \lambdaTwo{}.
The constructions used for this are mainly based on \cite{2} but the proofs go much more into detail.

