\section{Basic Definitions}
\subsection{$\lambda$-calculus \lambdaTwo}
In the following let $\lambdaTypVar=\{\alpha,a,\beta,b,\dots\}$ be a countably infinite set (of type-variables) and $\lambdaValVar=\{x,x_1,x_2,\dots\}$ be a countably infinite set (of value-variables).
\begin{definition}
	The \define{set of all $\lambda2$ types over \lambdaTypVar}, denoted by \lambdaTypes{}, is the smallest set T satisfying the following conditions: %TODO maybe put \lambdaTypVar in \lambdaTypes
	\begin{itemize}
		\item $\lambdaTypVar\subseteq\text{T}$,
		\item if $t_1,t_2\in\text{T}$ then $(t_1\to t_2)\in\text{T}$, and
		\item if $t\in\text{T}$ and $\alpha\in\lambdaTypVar$ then $\forall\alpha.t\in\text{T}$.
	\end{itemize}
	
	The \define{set of all $\lambda2$ terms over \lambdaTypVar{} and \lambdaValVar}, denoted by \lambdaTerms{}, is the smallest set $\Lambda_\text{T}$ satisfying the following conditions: %TODO lambda2 explicit
	\begin{itemize}
		\item $\lambdaValVar\subseteq\Lambda_\text{T}$,
		\item if $M_1,M_2\in\Lambda_\text{T}$ then $M_1M_2\in\Lambda_\text{T}$,
		\item if $x\in\lambdaValVar$, $t\in\lambdaTypes$, and $M\in\Lambda_\text{T}$ then $\lambda x:t.M\in\Lambda_\text{T}$,
		\item if $\alpha\in\lambdaTypVar$ and $M\in\Lambda_\text{T}$ then $\Lambda \alpha.M\in\Lambda_\text{T}$, and
		\item if $M\in\Lambda_\text{T}$ and $t\in\lambdaTypes$ then $M\,t\in\Lambda_\text{T}$.
	\end{itemize}
\end{definition}
If we have a type of the form $(t_1\to(t_2\to(\dots \to(t_{n-1}\to t_n)\cdots)))$ we will often omit the brackets and just write $(t_1\to t_2\to\dots\to t_{n-1}\to t_n)$ or $t_1\to t_2\to\dots \to t_{n-1}\to t_n$ instead. %TODO \vec{\alpha}
\begin{definition}
	Let $t\in\lambdaTypes$. The \define{set of free variables of $t$}, denoted by $\FV(t)$, is defined inductively as follows:
		\[\FV(t)=
			\begin{cases}
				\{a\}                 & \text{if $t=a$}                    \\ 
				\FV(t_1)\cup\FV(t_2)  & \text{if $t=t_1\to t_2$}           \\
				\FV(t')\setminus\{\alpha\} & \text{if $t=\forall\alpha.t'$}\\
			\end{cases}\]
			
	Let $M\in\lambdaTerms$. The \define{set of free variables of $M$}, denoted by $\FV(M)$, is defined inductively as follows:
	\[\FV(M)=
		\begin{cases}
			\{x\}                 & \text{if $M=x$}                \\ %TODO, for some $x\in\lambdaValVar$?
			\FV(M_1)\cup\FV(M_2)  & \text{if $M=M_1M_2$}           \\
			\FV(M')\setminus\{x\} & \text{if $M=\lambda x:t.M'$}   \\
			\FV(M')               & \text{if $M=\Lambda\alpha.M'$} \\
			\FV(M')               & \text{if $M=M'\,t$}            \\
		\end{cases}\]
\end{definition}
\begin{definition} Let $\mathcal{V}=\{x_1,\dots,x_n\}$ be a finite subset of \lambdaValVar{} and $t_1,\dots,t_n\in\lambdaTerms$.	A \define{\lambdaTwo-basis} $\Gamma=\{(x_1:t_1),\dots,(x_n:t_n)\}$ is a mapping from $\mathcal{V}$ to \lambdaTypes{}. If the kind of basis is clear from the context we abbreviate \lambdaTwo-basis to basis. 

The \define{free variables of a basis} $\Gamma$, denoted by $\FV(\Gamma)$, are $\bigcup\{\FV(t)\mid(x:t)\in\Gamma\}$.
\end{definition}

For a basis $\Gamma$ and another basis $\Sigma$, $x\in\lambdaValVar\setminus\dom(\Gamma)$, and $t\in\lambdaTypes$ we will abbreviate $\Gamma\cup\{(x:t)\}$ to $\Gamma,x:t$ and $\Gamma\cup\Sigma$ to $\Gamma,\Sigma$. %TODO is the second convention use?

\begin{definition}
Let $M$ be in \lambdaTerms{}, $t$ in \lambdaTypes, and $\Gamma$ be a basis. A statement $M:t$ is \define{derivable} from $\Gamma$, denoted by $\Gamma\lambdaModels M:t$, if $M:t$ can be produced using the following rules.
\begin{mdframed} 
	\begingroup
	\addtolength{\jot}{0.3cm}
	\begin{align*}
		&(\text{Axiom}) &&\Gamma,x:t\lambdaModels x:t\vphantom{\frac{t_1}{t_1}}\\
		&(\lambda\text{-Introduction}) &&\frac{\Gamma,x:t_1\lambdaModels M:t_2}{\Gamma\lambdaModels \lambda x:t_1.M:t_1\to t_2}\\
		&(\lambda\text{-Elimination}) &&\frac{\Gamma\lambdaModels M_1:t_1\to t_2 \hspace{0.4cm}\Gamma\lambdaModels M_2:t_1}{\Gamma\lambdaModels M_1M_2:t_2}\\
& (\forall\text{-Introduction}) &   & \frac{\Gamma\lambdaModels M:t}{\Gamma\lambdaModels \Lambda\alpha.M:\forall\alpha.t}                 &   & \alpha\notin\FV(\Gamma) \\
& (\forall\text{-Elimination})  &   & \frac{\Gamma\lambdaModels M:\forall\alpha.t }{\Gamma\lambdaModels M\,t':t\left[ \alpha:=t'\right] } 
	\end{align*}
	\endgroup
\end{mdframed}
\end{definition}

\begin{definition}
The inhabitation problem for $\lambda2$, denoted by \lambdaInhab, is defined as follows. Given a $\lambda2$ type $t$.
\[\text{Is there a $\lambda2$ term $M$ such that } \emptyset\lambdaModels M:t?\]
But we can rephrase this problem so that it becomes more general:
Given a basis $\Gamma$ and a $\lambda2$ type $t$.
\[\text{Is there a $\lambda2$ term $M$ such that } \Gamma\lambdaModels M:t?\]
Obviously the second version is a special case of the first one. For the other direction consider a basis $\Gamma=\{(x_1:t_1),\dots,(x_n:t_n)\}$ and a $\lambda2$ type $t$. Clearly, for every term $M$, $\Gamma\lambdaModels M:t$ holds iff $\emptyset\lambdaModels \lambda x_1:t_1.\dots\lambda x_n:t_n.M:t_1\to\dots\to t_n\to t$.
\end{definition}
\subsection{first-order logic}
\begin{definition}
	A \define{ranked set} is a tuple $(\Sigma,\rank)$, where $\Sigma$ is a countable set and $\rank\colon\Sigma\to\N$ is a function that maps every symbol from $\Sigma$ to a natural number (its rank).
\end{definition}
If the function \rank{} is understood we will just write $\Sigma$ instead of $(\Sigma,\rank)$. The set of all elements in $\Sigma$ with a certain rank $k$, denoted by $\Sigma^{(k)}$, is defined as $\Sigma^{(k)}:=rk^{-1}(k)$. 
%In the following we will write $\Sigma=\{P^{(0)},Q^{(3)}\}$ to say that $\Sigma=\{P,Q\}$, $\rank(P)=0$, and $\rank(Q)=3$.
%TODO do we use this convention?


For the remainder of this subsection let $\mathcal{V}=\{y,y_1,y_2,\dots\}$ be a countable set (of variables), $\mathcal{F}$ a ranked set (of function symbols), and $\mathcal{P}$ a ranked set (of predicate symbols).
\begin{definition}
	The set of \define{terms over $\mathcal{V}$ and $\mathcal{F}$}, denoted by $\mathcal{T}_{(\mathcal{V},\mathcal{F})}$, is the smallest set $\mathcal{T}$ satisfying the following conditions:
	\begin{itemize}
		\item $\mathcal{V} \subseteq \mathcal{T}$, and
		\item for every $k\in\N$, if $f\in\mathcal{F}^{(k)}$ and $t_1,t_2,\dots,t_k\in\mathcal{T}$ then $f(t_1,t_2,\dots,t_k)\in\mathcal{T}$.
	\end{itemize}
	The set of \define{first-order formulas over $\mathcal{V}$, $\mathcal{F}$, and $\mathcal{P}$}, denoted by $\mathcal{L}_{(\mathcal{V},\mathcal{F},\mathcal{P})}$, is the smallest set $\mathcal{L}$ satisfying the following conditions:
	\begin{itemize}
		\item for every $k\in\N$, if $P\in\mathcal{P}^{(k)}$ and $t_1,t_2,\dots,t_k\in\mathcal{T}_{(\mathcal{V},\mathcal{F})}$ then $P(t_1,t_2,\dots,t_k)\in\mathcal{L}$.
		\item If $\varphi,\psi\in\mathcal{L}$ then $(\varphi\wedge\psi)$, $(\varphi\vee\psi)$, $\neg \varphi\in\mathcal{L}$, and
		\item if $y\in\mathcal{V}$ and $\varphi\in\mathcal{L}$ then $\exists y.\varphi$, $\forall y.\varphi\in\mathcal{L}$.
	\end{itemize}
\end{definition}
We introduce an additional binary operation $\to$ on formulas, where for some $\varphi$, $\psi\in\mathcal{L}_{(\mathcal{V},\mathcal{F},\mathcal{P})}$ the formula $(\varphi\to\psi)$ is defined as $(\neg\varphi\vee\psi)$, if we have a formula of the form $(\varphi_1\to(\varphi_2\to(\dots \to(\varphi_{n-1}\to \varphi_n)\cdots)))$ we will often omit the brackets and just write $(\varphi_1\to \varphi_2\to\dots\to \varphi_{n-1}\to \varphi_n)$ or $\varphi_1\to \varphi_2\to\dots \to \varphi_{n-1}\to \varphi_n$ instead. 

For nullary relation symbols $P$ we will abbreviate $P()$ to $P$. If a formula $\varphi$ is of the form $Qy.(\psi)$ (where $Q\in\{\exists,\forall\}$, $y\in\mathcal{V}$, and $(\psi)\in\mathcal{L}_{(\mathcal{V},\mathcal{F},\mathcal{P})}$) we often drop the dot and write $Qy(\psi)$ instead. %TODO why brackets around varphi? maybe so that you cannot use this for a negated formula or smth like that
If a formula $\varphi$ has multiple variables bound by the same quantifier (i.e. $\varphi=Qy_1.Qy_2.\dots Qy_n.\psi$ for $Q\in\{\exists,\forall\}$, some $n\in\N$, $y_1,y_2,\dots,y_n\in\mathcal{V}$, and $\psi\in\mathcal{L}_{(\mathcal{V},\mathcal{F},\mathcal{P})}$) we abbreviate $\varphi$ to $Qy_1y_2\dots y_n.\psi$ or to $Q\vec{y}.\psi$ where $\vec{y}=y_1y_2\dots y_n$.

\begin{definition}
	The \define{set of variables of a term $t\in\mathcal{T}_{(\mathcal{V},\mathcal{F})}$}, denoted by $\V(t)$, is defined by:
	\[\V(t)=
		\begin{cases}
			\{y\}                                    & \text{if $t=y$}                    \\ %TODO for some x in V?
			\V(t_1)\cup \V(t_2)\cup\dots\cup \V(t_k) & \text{if $t=f(t_1,t_2,\dots,t_k)$} 
		\end{cases}\]
	
	The \define{set of free variables of a formula $\varphi\in\mathcal{L}_{(\mathcal{V},\mathcal{F},\mathcal{P})}$}, denoted by $\FV(\varphi)$, is defined as follows:
	\[\FV(\varphi)=
		\begin{cases} %TODO for some?
			\V(t_1)\cup \V(t_2)\cup\dots\cup \V(t_k) & \text{if $\varphi=P(t_1,t_2,\dots,t_k)$}                               \\
			\FV(\psi)                                 & \text{if $\varphi=\neg\psi$}                               \\
			\FV(\varphi_1)\cup\FV(\varphi_2)         & \text{if $\varphi=(\varphi_1\wedge\varphi_2)$ or $\varphi=(\varphi_1\vee\varphi_2)$} \\
			\FV(\psi)\setminus\{y\}                  & \text{if $\varphi=\forall y.\psi$ or $\varphi=\exists y.\psi$}                 
		\end{cases}\]
\end{definition}

\begin{definition}
	Let $y$ be in $\mathcal{V}$ and $t,t'\in\mathcal{T}_{(\mathcal{V},\mathcal{F})}$. The \define{substitution of $y$ by $t'$ in $t$}, denoted by $t\left[y:=t'\right]$, is defined as follows:
	\[t\left[y:=t'\right]=
		\begin{cases}
			t'                                                   & \text{if $t=y$}                \\ 
			z                                                    & \text{if $t=z$ and $z\neq y$}  \\%TODO for some
			f(t_1\left[y:=t'\right],\dots,t_k\left[y:=t'\right]) & \text{if $t=f(t_1,\dots,t_k)$} 
		\end{cases}\]
	
	Now we can lift this definition to formulas, let $\varphi$ be in $\mathcal{L}_{(\mathcal{V},\mathcal{F},\mathcal{P})}$. The \define{substitution of $y$ by $t'$ in $\varphi$}, denoted by $\varphi\left[y:=t'\right]$, is defined as follows:
	\[\varphi\left[y:=t'\right]=
		\begin{cases}
			%TODO quantify k?
			P(t_1\left[y:=t'\right],\dots,t_k\left[y:=t'\right])        & \text{if $\varphi=P(t_1,\dots,t_k)$}                                     \\
			\neg(\psi\left[y:=t'\right])                                      & \text{if $\varphi=\neg\psi$}                                             \\ %TODO \neg\psi' where \psi'=\psi[y:=t']
			\varphi_1\left[y:=t'\right]\circ\varphi_2\left[y:=t'\right] & \text{if $\varphi=(\varphi_1\circ\varphi_2)$ , $\circ\in\{\wedge,\vee\}$} \\
			\varphi                                                     & \text{if $\varphi=\forall y.\psi$ or $\varphi=\exists y.\psi$}                   \\
			Q z.(\psi\left[y:=t'\right])                                 & \text{if $\varphi=Q z.\psi$, $Q\in\{\forall,\exists\}$ and $z\neq y$}     
		\end{cases}\]

\end{definition}
Now we come to the semantics of first-order formulas.
\begin{definition}
	An \define{interpretation $I$ over $\mathcal{V}$, $\mathcal{F}$, and $\mathcal{P}$} is a triple $I=(\Delta,\cdot^I,\omega)$,
	\begin{tabular}{llp{0.78\linewidth}}
		where & $\Delta$  & is a nonempty set (which we call  domain),                                                     \\
& $\cdot^I$ & is a function such that                                                                        \\
&           & $f^I\colon\Delta^k\to\Delta$  is a function for every $k\in\N$, $f\in\mathcal{F}^{(k)}$ and \\
&           & $P^I\subseteq\Delta^k$ is a relation for every $k\in\N$, $P\in\mathcal{P}^{(k)}$       \\
& $\omega$  & is a function from $\mathcal{V}$ to $\Delta$.                                                  
	\end{tabular}
\end{definition}
Let $I=(\Delta,\cdot^I,\omega)$ be an interpretation, $y\in\mathcal{V}$, and $d\in\Delta$ the interpretation $I\left[y\mapsto d\right]$ is defined as $(\Delta,\cdot^I,\omega\left[y\mapsto d\right])$ where
\[(\omega\left[y\mapsto d\right])(z)=
	\begin{cases}
		d         & \text{if $z=y$}   \\
		\omega(y) & \text{otherwise.} 
	\end{cases}\]
\begin{definition}
	Let $I=(\Delta,\cdot^I,\omega)$ be an interpretation and $t$ a term. The \define{interpretation of $t$ under $I$}, denoted by $t^I$, is defined as follows:
	\[t^I=
		\begin{cases}
			\omega(y)              & \text{if $t=y$}                \\
			f^I(t^I_1,\dots,t^I_k) & \text{if $t=f(t_1,\dots,t_k)$} 
		\end{cases}\]
		
	Let $\varphi$ be a formula. The \define{interpretation of $\varphi$ under $I$}, denoted by $\varphi^I$, is defined recursively as follows:
	\[\varphi^I=
		\begin{cases}
			%TODO quantify k?
			\top                                                   & \text{if $\varphi=P(t_1,\dots,t_k)$ and $(t^I_1,\dots,t^I_k)\in P^I$}    \\
			\bot                                                   & \text{if $\varphi=P(t_1,\dots,t_k)$ and $(t^I_1,\dots,t^I_k)\notin P^I$} \\
			\text{not}~\psi^I                                      & \text{if $\varphi=\neg\psi$}                                             \\
			\varphi^I_1~\text{and}~\varphi^I_2                     & \text{if $\varphi=(\varphi_1\wedge\varphi_2)$}                           \\
			\varphi^I_1~\text{or}~\varphi^I_2                      & \text{if $\varphi=(\varphi_1\vee\varphi_2)$}                             \\
			%TODO how to handle implies?
			\text{exists $d\in\Delta$}~\psi^{I\left[y\mapsto d\right]} & \text{if $\varphi=\exists y.\psi$}                                        \\
			\text{forall $d\in\Delta$}~\psi^{I\left[y\mapsto d\right]} & \text{if $\varphi=\forall y.\psi$}                                        \\
		\end{cases}\]
	The interpretation $I$ is a \define{model} of $\varphi$, denoted by $I\models\varphi$, if $\varphi^I=\top$.
\end{definition}
When we define an interpretation $I$ and we have a nullary predicate symbol $P$ we write $P^I=\top$ instead of $P^I=\{()\}$ and $P^I=\bot$ for $P^I=\emptyset$ (this works because $P()^I=\top$ iff $()\in P^I$).
\begin{definition} %TODO finite?
	Let $\Gamma$ be a finite set of first-order formulas.
	\begin{description}
		\item We say that an interpretation $I$ is a \define{model} of $\Gamma$, denoted by $I\models\Gamma$, if $I\models\psi$ for every $\psi$ in $\Gamma$.
		\item The formula $\varphi$ is a \define{semantic consequence} of $\Gamma$, denoted by $\Gamma\folmodels\varphi$, if every model of $\Gamma$ is also a model of $\varphi$.
		\item The free variables of $\Gamma$, denoted by $\FV(\Gamma)$, are $\bigcup\{\FV(\varphi)\mid \varphi\in \Gamma\}$.
	\end{description}
\end{definition}

\subsection{two-counter automaton} %TODO maby later in System P proof
We will use a version of two-counter automaton which only has two types of transitions. First it can increment a register and second it can decrement a register or jump if the register is already zero. Formally:
\begin{definition}
	A \define{deterministic two-counter automaton} is a 4-tuple $M=(\autStates,Q_0,Q_f,\autRules)$,
	\begin{tabular}{llp{0.78\linewidth}}
		where & $\autStates$ & is a finite set (of states),                                                                           \\
& $Q_0$        & is in $\autStates$ (the initial state),                                                                \\
& $Q_f$        & is in $\autStates$ (the final state), and                                                              \\
& $\autRules$  & is a function from $\autStates\setminus\{Q_f\}$ to $\mathcal{R}_\autStates$,                           \\
&              & where $\mathcal{R}_\autStates=\{+(i,Q')\mid i\in\{1,2\},Q'\in\autStates\}$                             \\
&              & ~ \hphantom{where $\mathcal{R}_\autStates$}$\cup\{-(i,Q_1,Q_2)\mid i\in\{1,2\},Q_1,Q_2\in\autStates\}$ 
	\end{tabular}\\
	A \define{configuration} $C$ of our automaton is a triple $C=\langle Q,m,n\rangle$, where $Q\in\autStates$ and $m,n\in\N$.
	Let $r$ be in $\autRules(\autStates\setminus\{Q_f\})$, then $\Rightarrow^r_M$ is a binary relation on the configurations of $M$ such that two configurations $\langle Q,m,n\rangle$, $\langle \widehat{Q},\widehat{m},\widehat{n}\rangle$ of $M$ are in the in the relation if all of the following conditions hold:
	\begin{itemize}
		\item $Q\neq Q_f$, $r=\autRules(Q)$,
		\item if $r=+(1,Q')$ for some $Q'\in \autStates$ then $\widehat{Q}=Q'$, $\widehat{m}=m+1$, and $\widehat{n}=n$,
		\item if $r=+(2,Q')$ for some $Q'\in \autStates$ then $\widehat{Q}=Q'$, $\widehat{m}=m$, and $\widehat{n}=n+1$,
		\item if $r=-(1,Q_1,Q_2)$ for some $Q_1,Q_2\in \autStates$ then
\subitem if $m=0$ then $\widehat{Q}=Q_2$, $\widehat{m}=0$, and $\widehat{n}=n$,
\subitem if $m\geq1$ then $\widehat{Q}=Q_1$, $\widehat{m}=m-1$, and $\widehat{n}=n$,
		\item if $r=-(2,Q_1,Q_2)$ for some $Q_1,Q_2\in \autStates$ then
\subitem if $n=0$ then $\widehat{Q}=Q_2$, $\widehat{m}=m$, and $\widehat{n}=0$,
\subitem if $n\geq1$ then $\widehat{Q}=Q_1$, $\widehat{m}=m$, and $\widehat{n}=n-1$.
	\end{itemize}
	The \define{transition relation of $M$}, denoted by $\Rightarrow_M$, is defined as $\bigcup_{r\in\autRules(Q\setminus\{Q_f\})}\Rightarrow^r_M$. We denote the transitive reflexive closure of $\Rightarrow_M$ by $\Rightarrow^*_M$
		
	Let $m$, $n$ be in $\N$, we say that \define{$M$ terminates on input $(m,n)$} if there exist $\widehat{m},\widehat{n}\in\N$ such that $\langle Q_0,m,n\rangle\Rightarrow^*_M\langle Q_f,\widehat{m},\widehat{n}\rangle$ (It follows that there exists an $i\in\N$ and configurations $D_1,\dots,D_i$ of $M$ such that $\langle Q_0,m,n\rangle= D_1\Rightarrow_M\dots\Rightarrow_M D_i=\langle Q_f,\widehat{m},\widehat{n}\rangle$, we call this chain a computation with length $i$).
\end{definition}
\begin{definition}
	The halting problem for two-counter automaton, denoted by \autHalt{}, is defined as follows.
	Given a two-counter automaton $M$. 
	\begin{center}
		Does $M$ terminate on input $(0,0)$?
	\end{center}
\end{definition}
It is well known that \autHalt{} is undecidable. %TODO find reference with proof
